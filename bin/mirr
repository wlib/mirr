#!/usr/bin/env ruby
# Mirr - Because you like synchronization
# Daniel Ethridge

#require "mirr"
#include Mirr
#require 'mirr/version'
require 'socket'
require 'fileutils'
require 'zlib'
require 'yaml'
require 'digest'

# 'argv' will be the lowercase version of 'ARGV', this helps for argument matching
argv = ARGV.map(&:downcase)
mdir = "#{Dir.home}/Mirr"
mset = "#{Dir.home}/.config/mirr"
usage = "Usage : `mirr [arguments]`
`mirr -h` is always there to help"
littleargs = "You don't have enough arguments, maybe your'e missing something important in your command?"
bigargs = "Too many arguments"
wrong = "Wrong syntax - `mirr -h` can help"
#version = Mirr::VERSION
help = "\n#{usage}

Mirr synchronizes all your work for you. That means you can do dev stuff from your 
desktop and your laptop. Without having to move your work folder to dropbox or something.

You need to set a file or directory if you didn't already. This is because mirr 
won't have anything to sync if you didn't add anything.

--------------------------------------------------

mirr add somefile      :   Add `somefile` to your synclist
mirr rm one two etc    :   Remove `one`, `two`, and `etc` from your synclist

mirr push work.rb      :   Push only `work.rb`, nothing else changes
mirr push              :   Push everything in your list to listening targets

--------------------------------------------------

If you find a bug, want extra features, or have a suggestion,
make a branch on github : https://github.com/wlib/mirr\n\n"

# Initialize mirr (first run)
def init(mdir, mset)
  # Does the mirr root directory even exist?
  unless File.directory?(mdir)
    puts "Initiating Mirr in #{mdir}, keep your files in there"
    require 'fileutils'
    FileUtils.mkdir_p(mdir)
  end
  # Does the mirr settings directory exist?
  unless File.directory?(mset)
    puts "Config files are in #{mset}"
    require 'fileutils'
    FileUtils.mkdir_p(mset)
  end
  # Does the file sync list exist?
  unless File.exist?("#{mset}/synclist.yml")
    File.open("#{mset}/synclist.yml", "w")
    puts "Created empty File sync list"
  else
    puts "File sync list already exists"
  end
  # Does the config file exist?
  unless File.exist?("#{mset}/config.yml")
    File.open("#{mset}/config.yml", "w")
    puts "Created empty config file"
  else
    puts "Config file already exists"
  end
  # Does the path mapping file exist?
  unless File.exist?("#{mset}/pathmap.yml")
    File.open("#{mset}/pathmap.yml", "w")
    puts "Created empty path mapping file"
  else
    puts "Path mapping file already exists"
  end
end

def combine(synclist, entries)
  # Serialize the current file for ruby
  syncread = File.read(synclist)
  synchash = YAML::load(syncread)
  # If the file was empty, make synchash an empty hash
  unless synchash.is_a?(Hash)
    synchash = {}
  end
  # Merge the hash of the original list with the new entries
  combination = synchash.merge!(entries)
  # Write the new list out
  sync = File.open(synclist, "w")
  sync.write combination.to_yaml
  sync.close
end

# Remove duplicate entries under the same ID
def rm_doubles(synclist)
  syncread = File.read(synclist)
  synchash = YAML::load(syncread)
  unique = synchash.to_a
  .uniq! { |_, v| v.values_at("path", "modtime", "checksum") }.to_h
  if unique.empty?; return end
  # Write the new list out
  sync = File.open(synclist, "w")
  sync.write unique.to_yaml
  sync.close
end

def add(array, synclist)
  entries = {}
  array.each do |fd|
    # Get absolute path for every file and directory
    fd = File.expand_path(fd)
    # ID is a random 5 char string + timestamp
    id = "#{rand(36**5).to_s(36)}#{Time.now.to_i}"
    name = File.basename(fd)
    type = File.ftype(fd)
    extention = File.extname(fd)
    modtime = File.mtime(fd).to_i
    if File.directory?(fd)
      # Merge each directory into `entries`
      entries.merge!( { id =>
        { "path" => fd,
          "name" => name,
          "type" => type,
          "extention" => extention,
          "modtime" => modtime }
      } )
      # Combine the entry with the synclist
      combine(synclist, entries)
      # Because it's a directory, recursion is needed to add() all its contents
      contents = Dir.glob("#{fd}/**/*", File::FNM_DOTMATCH).reject{ |e| File.basename(e) == "." }
      add(contents, synclist)
    elsif File.file?(fd)
      checksum = Digest::MD5.file(fd).hexdigest
      # Merge each file into `entries`
      entries.merge!( { id =>
        { "path" => fd,
          "name" => name,
          "type" => type,
          "extention" => extention,
          "modtime" => modtime,
          "checksum" => checksum }
      } )
      # Combine the entry with the synclist
      combine(synclist, entries)
    else
      puts "That is neither a file or directory"
    end
  end
  rm_doubles(synclist)
end

# Remove a file or directory from the sync list
def del(array, synclist)
  # Serialize the current file for ruby
  syncread = File.read(synclist)
  synchash = YAML::load(syncread)
  array.each do |entry|
    entry = File.expand_path(entry)
    if File.file?(entry)
      # Get the ID of the entry with the same path
      synchash.select{|key, hash| hash["path"] == entry}.keys.each do |delid|
        synchash.delete(delid)
      end
    elsif File.directory?(entry)
      # Get the ID of every entry within the directory
      synchash.select{|key, hash| hash["path"].start_with? entry}.keys.each do |delid|
        synchash.delete(delid)
      end
    end
  end
  # Write the new list out
  sync = File.open(synclist, "w")
  sync.write synchash.to_yaml
  sync.close
end

def add_origin(ip, config)
  puts "Setting origin in #{config} to #{ip}"
end

# Zlib to zip up files
def zip(file, dest)
  Zlib::GzipWriter.open(dest) do |gz|
    gz.write IO.binread(file)
    gz.close
  end
end

# Unzip into a given destination
def unzip(file, dest)
  Zlib::GzipReader.open(file) do |gz|
    orig = gz.read
    gz.close
    out = File.open(dest, "w")
    out.write orig
    out.close
  end
end

# Connect to a server, request a directory/file, and recieve zipped content
def retrieve(synclist)
end

# Push to any computer running mirr already
def push(files="all")
  puts "Pushing #{files} to all listening mirr targets"
end

# If not done yet, automatically initialize mirr
unless File.directory?(mdir)
  init(mdir, mset)
end
# If there is no sync list, initialize mirr again
unless File.file?("#{mset}/synclist.yml")
  init(mdir, mset)
end

# If there are no arguments, display a message to help you remember what the program does
if ARGV.length == 0; puts "Mirr syncs stuff for you, remember how to use it\n#{usage}"; exit end

# Argument parser determines how exactly mirr should behave
case argv[0]
  when "help", "-h", "--help"
    puts help
    exit
  when "init", "--init"
    init(mdir, mset)
    exit
  when "origin"
    set_origin(argv[1], "#{mset}/config.yml}")
    puts "Set #{argv[1]} to be origin"
    exit
  when "add", "--add", "-a", "+"
    if argv.length < 2; puts littleargs; exit end
    puts "Adding..."
    add(ARGV[1..-1], "#{mset}/synclist.yml")
    puts "Successfully added"
    exit
  when "del", "--del", "-d", "-", "rm"
    if argv.length < 2; puts littleargs; exit end
    puts "Removing..."
    del(ARGV[1..-1], "#{mset}/synclist.yml")
    puts "Successfully removed"
    exit
  when "push", "--push"
    if argv.length < 2 ; push()
    else puts bigargs; exit end
    puts "Pushed"
    exit
  else
    puts usage
    exit
end
