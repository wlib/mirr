#!/usr/bin/env ruby
# Mirr - Because you like synchronization
# Daniel Ethridge

#require "mirr"
#include Mirr
#require 'mirr/version'
require 'socket'
require 'rubygems/package'
require 'fileutils'
require 'zlib'

# 'argv' will be the lowercase version of 'ARGV', this helps for argument matching
argv = ARGV.map(&:downcase)
mdir = "#{Dir.home}/.mirr"
usage = "Usage : `mirr [arguments]`
To start the server (necessary to allow other computer to pull from you) run `mirrd`
`mirr -h` is always there to help"
littleargs = "You don't have enough arguments, maybe your'e missing something important in your command?"
bigargs = "Too many arguments"
wrong = "Wrong syntax - `mirr -h` can help"
#version = Mirr::VERSION
help = "\n#{usage}

Mirr synchronizes all your work for you. That means you can do dev stuff from your 
desktop and your laptop. Without having to move your work folder to dropbox or something.

You need to set a file or directory if you didn't already. This is because mirr 
won't have anything to sync if you didn't add anything. The most important thing 
to know is that there is always as master to mirror/sync/fetch from, or push to.

--------------------------------------------------

mirr add myfolder      :   Add 'myfolder' to sync list
mirr del somefile      :   Remove 'somefile' from sync list

mirr set time 10am     :   Set mirr to sync at 10 am everyday
mirr set every 02:45   :   Set mirr to sync every 2 hours, 45 minutes

mirr pull              :   Pull everything right now
mirr push work.rb      :   Push only 'work.rb', nothing else changes

--------------------------------------------------

If you find a bug, want extra features, or have a suggestion,
make a branch on github : https://github.com/wlib/mirr\n\n"

def init()
  puts "Initiating Mirr in #{mdir}, lists of files will be kept there"
  unless File.directory?("#{mdir}")
    require 'fileutils'
    FileUtils.mkdir_p("#{mdir}")
  end
  unless File.exist?("#{mdir}/files.sync")
    File.open("#{mdir}/files.sync", "w")
    puts "Created File sync list"
  else
    puts "File sync list already exists, abort"
    exit
  end
  unless File.exist?("#{mdir}/mirr.config")
  end
end

def add(src)
  
end

def del(target)
  
end

def set_time()

end

def set_every()

end

def set_master(ip)

end

# Unzip into destination/zipfilename
def unzip(file, dest)
  Zip::ZipFile.open(file) do |zf|
   zf.each do |f|
     out = "#{dest}/#{f.basename}"
     FileUtils.mkdir_p(out)
     zf.extract(f, out)
   end
  end
end

# Connect to a server, request a directory/file, and recieve a zipped version
def pull(filenames="all", ip="master")
  socket = TCPSocket.new("#{ip}", 7122)
  socket.write filenames
  data = socket.read
  puts data
  socket.close
  exit
end

# Push to any computer running the mirr daemon
def push(files="all", ip="target")
  puts "Pushing #{files} to #{ip}"
end

unless File.directory?("#{Dir.home}/.mirr")
  require 'fileutils'
  FileUtils.mkdir_p("#{Dir.home}/.mirr")
end

if ARGV.length == 0; puts "Mirr syncs stuff for you, remember how to use it\n#{usage}"; exit end

case argv[0]
  when "-h", "--help", "help"
    puts help
    exit
  when "init"
    init()
    exit
  when "add", "--add", "-a", "+"
    if argv.length < 2; puts littleargs; exit end
    add(ARGV[1])
    puts "Added #{ARGV[1]} to the sync list"
    exit
  when "del", "--del", "-d", "-", "rm"
    if argv.length < 2; puts littleargs; exit end
    del(ARGV[1])
    puts "Removed #{ARGV[1]} from sync list"
    exit
  when "set", "--set", "-s"
    if argv.length < 3; puts littleargs; exit end
    case argv[1]
      when "time"
        set_time()
        puts "Now set to sync everything at #{argv[2]} everyday"
        exit
      when "every"
        set_every()
        puts "Now set to sync every #{argv[2]}"
        exit
      when "master"
        set_master(argv[2])
        puts "Set #{argv[2]} to be master"
        exit
      else
        puts wrong
    end
  when "pull", "--pull"
    if argv.length < 2 ; pull()
    elsif argv.length == 2; pull(argv[1])
    elsif argv.length == 3; pull(argv[1], argv[2])
    else puts bigargs; exit end
    puts "Pulled"
  when "push", "--push"
    if argv.length < 2 ; push()
    elsif argv.length == 2; push(argv[1])
    elsif argv.length == 3; push(argv[1], argv[2])
    else puts bigargs; exit end
    puts "Pushed"
  else
    puts usage
    exit
end
