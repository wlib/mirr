#!/usr/bin/env ruby
# Mirr - Because you like synchronization
# Daniel Ethridge

#require "mirr"
#include Mirr
#require 'mirr/version'
require 'socket'
require 'fileutils'
require 'zlib'
require 'yaml'
require 'digest'

# 'argv' will be the lowercase version of 'ARGV', this helps for argument matching
argv = ARGV.map(&:downcase)
mset = "#{Dir.home}/.config/mirr"
usage = "Usage : `mirr [arguments]`
`mirr -h` is always there to help"
littleargs = "You don't have enough arguments, maybe your'e missing something important in your command?"
bigargs = "Too many arguments"
wrong = "Wrong syntax - `mirr -h` can help"
#version = Mirr::VERSION
help = "\n#{usage}

Mirr synchronizes all your work for you. That means you can do dev stuff from your 
desktop and your laptop. Without having to move your work folder to dropbox or something.

You need to set a file or directory if you didn't already. This is because mirr 
won't have anything to sync if you didn't add anything.

--------------------------------------------------

mirr add somefile      :   Add `somefile` to your synclist
mirr rm one two etc    :   Remove `one`, `two`, and `etc` from your synclist

mirr push work.rb      :   Push only `work.rb`, nothing else changes
mirr push              :   Push everything in your list to listening targets

--------------------------------------------------

If you find a bug, want extra features, or have a suggestion,
make a branch on github : https://github.com/wlib/mirr\n\n"

# Initialize mirr (first run)
def init(mset)
  # Does the mirr settings directory exist?
  unless File.directory?(mset)
    puts "Config files are in #{mset}"
    require 'fileutils'
    FileUtils.mkdir_p(mset)
  end
  # Does the file sync list exist?
  unless File.exist?("#{mset}/synclist.yml")
    File.open("#{mset}/synclist.yml", "w")
    puts "Created empty File sync list"
  else
    puts "File sync list already exists"
  end
  # Does the config file exist?
  unless File.exist?("#{mset}/config.yml")
    File.open("#{mset}/config.yml", "w")
    puts "Created empty config file"
  else
    puts "Config file already exists"
  end
end

def writelist(hash, list, overwrite=false)
  listread = File.read(list)
  unless listread.empty?
    listhash = YAML::load(listread)
  else
    listhash = {}
  end
  if overwrite
    out = hash
  # Merge the hash of the original list with the new hash
  elsif ! overwrite
    out = listhash.merge!(hash)
  end
  # Write the new list out
  file = File.open(list, "w")
  file.write out.to_yaml
  file.close
end

def loading(fps=10)
  chars = %w[| / - \\]
  delay = 1.0/fps
  iter = 0
  spinner = Thread.new do
    while iter do  # Keep spinning until told otherwise
      print chars[(iter+=1) % chars.length]
      sleep delay
      print "\b"
    end
  end
  yield.tap{       # After yielding to the block, save the return value
    iter = false   # Tell the thread to exit, cleaning up after itself…
    spinner.join   # …and wait for it to do so.
  }                # Use the block's return value as the method's
end

def add(array, synclist, entries={})
  # Serialize the current synclist, but if it's empty, fall back to an empty hash
  syncread = File.read(synclist)
  unless syncread.empty?
    synchash = YAML::load(syncread)
  else
    synchash = {}
  end
  # Explode directories and return a larger, complete array
  finalarray = []
  array.each do |ex|
    # Get the absolute path of each item in the array to make things easier
    ex = File.expand_path(ex)
    if File.directory?(ex)
      finalarray << Dir.glob("#{ex}/**/*", File::FNM_DOTMATCH).select{ |e| File.file?(e) }
    elsif File.file?(ex)
      finalarray << ex
    end
  end
  # Flatten the array
  finalarray = finalarray.flatten
  # Iterate through the final array to add everything
  finalarray.each do |fd|
    # The MD5 checksum is used as a key to identify files
    md5sum = Digest::MD5.file(fd).hexdigest
    # Type is almost always a file, but special files differ
    type = File.ftype(fd)
    # If there is an entry already with the same MD5 checksum, append the path
    if synchash[md5sum]
      paths = synchash[md5sum]["paths"]
      paths << fd
    else
      paths = [fd]
    end
    # Merge each file into `entries`
    entries.merge!( { md5sum =>
      { "type" => type,
        "paths" => paths }
    } )
  end
  writelist(entries, synclist)
end

# Remove a file from the sync list
def del(array, synclist)
  # Serialize the current file for ruby
  syncread = File.read(synclist)
  synchash = YAML::load(syncread)
  array.each do |entry|
    # Expand path to make things easier to match
    entry = File.expand_path(entry)
    # MD5 checksum of the file for selection
    md5sum = Digest::MD5.file(entry).hexdigest
    # Select the path of the file and remove it
    del = synchash[md5sum]["paths"]
    # Find out if this is one file or a big directory
    if File.file?(entry)
      del.delete(entry)
      # If the paths key holds an empty array now, remove the file entirely
      if del.empty?
        synchash.delete(md5sum)
      end
    elsif File.directory?(entry)
      puts "dir"
    end
  end
  writelist(synchash, synclist, true)
end

def add_origin(ip, config)
  puts "Setting origin in #{config} to #{ip}"
end

# Zlib to zip up files
def zip(file, dest)
  Zlib::GzipWriter.open(dest) do |gz|
    gz.write IO.binread(file)
    gz.close
  end
end

# Unzip into a given destination
def unzip(file, dest)
  Zlib::GzipReader.open(file) do |gz|
    orig = gz.read
    gz.close
    out = File.open(dest, "w")
    out.write orig
    out.close
  end
end

# Connect to a server, request a file or set of files, and recieve zipped content
def retrieve(synclist)
end

# Push to any computer running mirr as a daemon
def push(files="all")
  puts "Pushing #{files} to all listening mirr targets"
end

# If a key file is missing, initialize mirr again
if ! File.file?("#{mset}/synclist.yml")
  init(mset)
end

# If there are no arguments, display a message to help you remember what the program does
if ARGV.length == 0; puts "Mirr syncs stuff for you, remember how to use it\n#{usage}"; exit end

# Argument parser determines how exactly mirr should behave in the console
case argv[0]
  when "help", "-h", "--help", "h", "?"
    puts help
    exit
  when "init", "--init"
    init(mset)
    exit
  when "add", "--add", "-a", "plus", "--plus", "sync", "--sync" "+"
    if argv.length < 2; puts littleargs; exit end
    if ARGV[1..-1].empty?
      puts "You can't have empty arguments"
      exit
    end
    print "Adding..."
    loading(){
      add(ARGV[1..-1], "#{mset}/synclist.yml")
    }
    puts "Successfully added"
    exit
  when "rm", "remove", "--remove", "delete", "--delete", "del", "--del", "-d", "-"
    if argv.length < 2; puts littleargs; exit end
    if ARGV[1..-1].empty?
      puts "You can't have empty arguments"
      exit
    end
    print "Removing..."
    loading(){
      del(ARGV[1..-1], "#{mset}/synclist.yml")
    }
    puts "Successfully removed"
    exit
  when "push", "--push", "p", "-p", "publish", "--publish", "deploy", "--deploy"
    if ARGV[1..-1].empty?
      puts "You can't have empty arguments"
      exit
    end
    push(ARGV[1..-1])
    puts "Pushed"
    exit
  else
    puts usage
    exit
end