#!/usr/bin/env ruby
# Mirr - Because you like synchronization
# Daniel Ethridge

#require "mirr"
#include Mirr
#require 'mirr/version'
require 'socket'
require 'fileutils'
require 'zlib'
require 'yaml'
require 'digest'

# 'argv' will be the lowercase version of 'ARGV', this helps for argument matching
argv = ARGV.map(&:downcase)
mset = "#{Dir.home}/.config/mirr"
usage = "Usage : `mirr [arguments]`
`mirr -h` is always there to help"
littleargs = "You don't have enough arguments, maybe your'e missing something important in your command?"
wrong = "Wrong syntax - `mirr -h` can help"
#version = Mirr::VERSION

help = "\n#{usage}

Mirr synchronizes all your work for you. That means you can do dev stuff from your 
desktop and your laptop. Without having to move your work folder to dropbox or something.

Mirr works pretty simply, you can push, pull, and sync files and directories
with other computers. To get started, the first step is to add a file or directory. 
This will tell mirr it needs to keep track of it. If at any point you change a file in
the directory you added, change the directory's path, add or delete files, you will need
to tell mirr to update/refresh its database.

--------------------------------------------------

( Local usage )
mirr add somefile            :   Add `somefile` to your synclist
mirr rm one two etc          :   Remove `one`, `two`, and `etc` from your synclist
mirr ignore ./private        :   Skip over every file in the directory `./private` don't share them

( Network usage )
mirr pull 10.0.0.25          :   Pull everything from the computer named 10.0.0.25
mirr push 10.0.0.34 work.rb  :   Push only `work.rb`, nothing else changes
mirr push all                :   Push everything in your list to every computer in your config
mirr sync old-laptop         :   Synchronize everything both you and the computer named `old-laptop` have

--------------------------------------------------

If you find a bug, want extra features, or have a suggestion,
make a branch on github : https://github.com/wlib/mirr\n\n"

# Initialize mirr - on first run or when key settings files are missing
def init(mset)
  # Does the mirr settings directory exist?
  unless File.directory?(mset)
    puts "Config files are in #{mset}"
    require 'fileutils'
    FileUtils.mkdir_p(mset)
  end
  # Does the file list exist?
  unless File.exist?("#{mset}/filelist.yml")
    File.open("#{mset}/filelist.yml", "w")
    puts "Created empty File list"
  else
    puts "File list already exists"
  end
  # Does the sync list exist?
  unless File.exist?("#{mset}/synclist.yml")
    File.open("#{mset}/synclist.yml", "w")
    puts "Created empty sync list"
  else
    puts "Sync list already exists"
  end
  # Does the config file exist?
  unless File.exist?("#{mset}/config.yml")
    File.open("#{mset}/config.yml", "w")
    puts "Created empty config file"
  else
    puts "Config file already exists"
  end
end

# Write a given hash to a yaml file, either merging the two or overwriting
def writelist(hash, list, overwrite=false)
  # Serialize the file if we choose to merge, if the file is empty, just overwrite
  unless overwrite
    listread = File.read(list)
    unless listread.empty?
      listhash = YAML::load(listread)
      out = listhash.merge!(hash)
    else
      out = hash
    end
  else
    out = hash
  end
  # Write the new list out
  file = File.open(list, "w")
  file.write out.to_yaml
  file.close
end

# Loading animations help the user know there isn't a freeze
def loading(fps=10)
  chars = %w[| / - \\]
  delay = 1.0/fps
  go = true
  i = 0
  spinner = Thread.new do
    while go do
      print chars[(i+=1) % chars.length]
      sleep delay
      print "\b"
    end
  end
  yield.tap{
    go = false
    spinner.join
  }
end

# Refresh the synclist
def refresh(filelist, synclist)
  # Serialize the current file list, but if it's empty, exit with a warning
  flread = File.read(filelist)
  unless flread.empty?
    flhash = YAML::load(flread)
    array = flhash["add"]
  else
    puts "There is no filelist"
    exit
  end
  # Serialize the current synclist, but if it's empty, fall back to an empty hash
  syncread = File.read(synclist)
  unless syncread.empty?
    synchash = YAML::load(syncread)
  else
    synchash = {}
  end
  # Explode directories and return an array of all the files to add
  exarray = []
  array.each do |ex|
    if File.directory?(ex)
      exarray << Dir.glob("#{ex}/**/*", File::FNM_DOTMATCH).select{ |e| File.file?(e) }
    elsif File.file?(ex)
      exarray << ex
    end
  end
  # Flatten the array and remove duplicate entries if they exist
  finalarray = exarray.flatten.uniq
  # Iterate through the final array to add everything to `entries`
  entries = {}
  finalarray.each do |fd|
    # Get the absolute path of each item in the array
    fd = File.expand_path(fd)
    # The ID is a 15 char random string
    id = rand(36**15).to_s(36)
    # The MD5 checksum is used to notify when file changes
    md5sum = Digest::MD5.file(fd).hexdigest
    # File type is almost always just `file`, but special files are different
    type = File.ftype(fd)
    # A modification time is needed so that we keep track of a file's latest version
    modtime = File.mtime(fd).to_i
    # Size returns the file size in bytes
    size = File.size(fd)
    # Merge each file into `entries`
    entries.merge!( { id =>
      { "type" => type,
        "size" => size,
        "modtime" => modtime,
        "md5sum" => md5sum,
        "path" => fd }
    } )
  end
  # Finally write it out to the synclist
  writelist(entries, synclist, true)
end

# Add a file or directory to the file list
def add(array, filelist, synclist)
  # Serialize the current file list
  flread = File.read(filelist)
  unless flread.empty?
   flhash = YAML::load(flread)
  else
    flhash = {"add" => [], "ignore" => []}
  end
  # Expand the path of each item in `array`
  entries = []
  array.each do |fd|
    entries << File.expand_path(fd)
  end
  # Append to the `add` array and remove doubles
  flhash["add"] = (flhash["add"] + entries).uniq
  # Write out to the file list and then refresh the synclist
  writelist(flhash, filelist)
  refresh(filelist, synclist)
end

# Remove a file or directory from the file list
def del(array, filelist, synclist)
  # Serialize the current file list
  flread = File.read(filelist)
  unless flread.empty?
   flhash = YAML::load(flread)
  else
    puts "No content to delete"
    exit
  end
  # Expand the path of each item in `array`
  entries = []
  array.each do |fd|
    entries << File.expand_path(fd)
  end
  # Simply remove entries from the `add` array
  flhash["add"] = (flhash["add"] - entries)
  # Write out to the file list and then refresh the synclist
  writelist(flhash, filelist)
  refresh(filelist, synclist)
end

# Add a computer to config
def addcomputer(ip, name, config)
  puts "Adding a computer named #{name} located at #{ip}to #{config}"
end

# Zlib to zip up files
def zip(file, dest)
  Zlib::GzipWriter.open(dest) do |gz|
    gz.write IO.binread(file)
    gz.close
  end
end

# Unzip into a given destination
def unzip(file, dest)
  Zlib::GzipReader.open(file) do |gz|
    orig = gz.read
    gz.close
    out = File.open(dest, "w")
    out.write orig
    out.close
  end
end

# Connect to a server, request a file or set of files
def pull(synclist, ips)
  puts "Pulling from #{ips}"
end

# Push to any computer running mirr as a daemon
def push(synclist, ips)
  puts "Pushing to #{ips}"
end

# If a key file is missing, initialize mirr again
if ! File.file?("#{mset}/synclist.yml")
  init(mset)
end

# If there are no arguments, display a message to help you remember what the program does
if ARGV.length == 0
  puts "Mirr syncs stuff for you, remember how to use it\n#{usage}"
  exit
end

# Argument parser determines how exactly mirr should behave in the console
case argv[0]
  when "help", "-h", "--help", "h", "?"
    puts help
    exit
  when "init", "--init"
    init(mset)
    exit
  when "add", "--add", "-a", "plus", "--plus", "sync", "--sync", "+"
    if argv.length < 2; puts littleargs; exit end
    print "Adding..."
    loading(){
      add(ARGV[1..-1], "#{mset}/filelist.yml", "#{mset}/synclist.yml")
    }
    puts "Successfully added"
    exit
  when "rm", "remove", "--remove", "delete", "--delete", "del", "--del", "-d", "-"
    if argv.length < 2; puts littleargs; exit end
    print "Removing..."
    loading(){
      del(ARGV[1..-1], "#{mset}/filelist.yml", "#{mset}/synclist.yml")
    }
    puts "Successfully removed"
    exit
  when "--refresh", "refresh", "reload", "re", "up", "-u", "u", "--update", "update", "updatedb"
    unless ARGV[1..-1].empty?
      puts "You can't refresh only one file or directory yet, ignoring extra arguments"
    end
    print "Refreshing the database..."
    loading(){
      refresh("#{mset}/filelist.yml", "#{mset}/synclist.yml")
    }
    puts "Successfully refreshed"
    exit
  when "push", "--push", "p", "-p", "publish", "--publish", "deploy", "--deploy"
    push(ARGV[1..-1])
    puts "Pushed"
    exit
  else
    puts usage
    exit
end