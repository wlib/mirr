#!/usr/bin/env ruby
# Mirr - Because you like synchronization
# Daniel Ethridge

#require "mirr"
#include Mirr
#require 'mirr/version'
require 'socket'
require 'fileutils'
require 'zlib'
require 'yaml'
require 'digest'

# 'argv' will be the lowercase version of 'ARGV', this helps for argument matching
argv = ARGV.map(&:downcase)
mset = "#{Dir.home}/.config/mirr"
usage = "Usage : `mirr [arguments]`
`mirr -h` is always there to help"
littleargs = "You don't have enough arguments, maybe your'e missing something important in your command?"
bigargs = "Too many arguments"
wrong = "Wrong syntax - `mirr -h` can help"
#version = Mirr::VERSION

help = "\n#{usage}

Mirr synchronizes all your work for you. That means you can do dev stuff from your 
desktop and your laptop. Without having to move your work folder to dropbox or something.

You need to set a file or directory if you didn't already. This is because mirr 
won't have anything to sync if you didn't add anything.

--------------------------------------------------

mirr add somefile      :   Add `somefile` to your synclist
mirr rm one two etc    :   Remove `one`, `two`, and `etc` from your synclist

mirr push work.rb      :   Push only `work.rb`, nothing else changes
mirr push              :   Push everything in your list to listening targets

--------------------------------------------------

If you find a bug, want extra features, or have a suggestion,
make a branch on github : https://github.com/wlib/mirr\n\n"

# Initialize mirr (first run)
def init(mset)
  # Does the mirr settings directory exist?
  unless File.directory?(mset)
    puts "Config files are in #{mset}"
    require 'fileutils'
    FileUtils.mkdir_p(mset)
  end
  # Does the file sync list exist?
  unless File.exist?("#{mset}/synclist.yml")
    File.open("#{mset}/synclist.yml", "w")
    puts "Created empty File sync list"
  else
    puts "File sync list already exists"
  end
  # Does the config file exist?
  unless File.exist?("#{mset}/config.yml")
    File.open("#{mset}/config.yml", "w")
    puts "Created empty config file"
  else
    puts "Config file already exists"
  end
end

def writelist(hash, list, overwrite=false)
  listread = File.read(list)
  unless listread.empty?
    listhash = YAML::load(listread)
  else
    listhash = {}
  end
  if overwrite
    out = hash
  # Merge the hash of the original list with the new hash
  elsif ! overwrite
    out = listhash.merge!(hash)
  end
  # Write the new list out
  file = File.open(list, "w")
  file.write out.to_yaml
  file.close
end

def loading(fps=10)
  chars = %w[| / - \\]
  delay = 1.0/fps
  iter = 0
  spinner = Thread.new do
    while iter do  # Keep spinning until told otherwise
      print chars[(iter+=1) % chars.length]
      sleep delay
      print "\b"
    end
  end
  yield.tap{       # After yielding to the block, save the return value
    iter = false   # Tell the thread to exit, cleaning up after itself…
    spinner.join   # …and wait for it to do so.
  }                # Use the block's return value as the method's
end

def add(array, synclist, entries={})
  # Serialize the current synclist, but if it's empty, fall back to an empty hash
  syncread = File.read(synclist)
  unless syncread.empty?
    synchash = YAML::load(syncread)
  else
    synchash = {}
  end
  # Explode directories and return a larger, complete array
  exarray = []
  array.each do |ex|
    if File.directory?(ex)
      exarray << Dir.glob("#{ex}/**/*", File::FNM_DOTMATCH).select{ |e| File.file?(e) }
    elsif File.file?(ex)
      exarray << ex
    end
  end
  # Flatten the array and remove duplicate entries if they exist
  finalarray = exarray.flatten.uniq
  # Iterate through the final array to add everything
  finalarray.each do |fd|
    # Get the absolute path of each item in the array to make things easier
    fd = File.expand_path(fd)
    # If this path is already in the list, skip item
    skip = false
    synchash.each do |key, values|
      if values["paths"].include?(fd)
        skip = true
      end
    end
    if skip
      next
    end
    # The ID is a 15 char random string
    id = rand(36**15).to_s(36)
    # The MD5 checksum is used as a key to identify files
    md5sum = Digest::MD5.file(fd).hexdigest
    # Type is almost always just `file`, but special files differ
    type = File.ftype(fd)
    # A modification time is needed so that we keep track of the latest versions
    modtime = File.mtime(fd).to_i
    # Other metadata is helpful for various reasons
    birthtime = File.birthtime(fd).to_i
    size = File.size(fd)
    # If there is an entry already with the same MD5 checksum, append the path
    paths = [fd]
    synchash.each do |key, values|
      if values["md5sum"].include?(md5sum)
        paths = values["paths"]
        paths << fd
      end
    end
    # Merge each file into `entries`
    entries.merge!( { id =>
      { "type" => type,
        "size" => size,
        "birthtime" => birthtime,
        "modtime" => modtime,
        "md5sum" => md5sum,
        "paths" => paths }
    } )
  end
  # Finally write it out to the synclist
  writelist(entries, synclist)
end

# Remove a file from the sync list
def del(array, synclist)
  # Serialize the current file for ruby
  syncread = File.read(synclist)
  synchash = YAML::load(syncread)
  array.each do |delfile|
    delpath = File.expand_path(delfile)
    id = synchash.select{|key, hash| hash["paths"] == [delpath] }.keys.join
    # If id is empty then exit
    if id.empty?
      puts "No such path"
      exit
    end
    pathskey = synchash[id]["paths"]
    # Find out if this is one file or a big directory
    if File.file?(delpath)
      pathskey.delete(delpath)
      # If the `paths` key is empty now, delete the entry
      if pathskey.empty?
        synchash.delete(id)
      end
    elsif File.directory?(delpath)
      puts "dir"
    end
  end
  # The last argument, `true` tells writelist() to overwrite
  writelist(synchash, synclist, true)
end

def add_origin(ip, config)
  puts "Setting origin in #{config} to #{ip}"
end

# Zlib to zip up files
def zip(file, dest)
  Zlib::GzipWriter.open(dest) do |gz|
    gz.write IO.binread(file)
    gz.close
  end
end

# Unzip into a given destination
def unzip(file, dest)
  Zlib::GzipReader.open(file) do |gz|
    orig = gz.read
    gz.close
    out = File.open(dest, "w")
    out.write orig
    out.close
  end
end

# Connect to a server, request a file or set of files, and recieve zipped content
def retrieve(synclist)
end

# Push to any computer running mirr as a daemon
def push(files="all")
  puts "Pushing #{files} to all listening mirr targets"
end

# If a key file is missing, initialize mirr again
if ! File.file?("#{mset}/synclist.yml")
  init(mset)
end

# If there are no arguments, display a message to help you remember what the program does
if ARGV.length == 0; puts "Mirr syncs stuff for you, remember how to use it\n#{usage}"; exit end

# Argument parser determines how exactly mirr should behave in the console
case argv[0]
  when "help", "-h", "--help", "h", "?"
    puts help
    exit
  when "init", "--init"
    init(mset)
    exit
  when "add", "--add", "-a", "plus", "--plus", "sync", "--sync" "+"
    if argv.length < 2; puts littleargs; exit end
    if ARGV[1..-1].empty?
      puts "You can't have empty arguments"
      exit
    end
    print "Adding..."
    loading(){
      add(ARGV[1..-1], "#{mset}/synclist.yml")
    }
    puts "Successfully added"
    exit
  when "rm", "remove", "--remove", "delete", "--delete", "del", "--del", "-d", "-"
    if argv.length < 2; puts littleargs; exit end
    if ARGV[1..-1].empty?
      puts "You can't have empty arguments"
      exit
    end
    print "Removing..."
    loading(){
      del(ARGV[1..-1], "#{mset}/synclist.yml")
    }
    puts "Successfully removed"
    exit
  when "push", "--push", "p", "-p", "publish", "--publish", "deploy", "--deploy"
    if ARGV[1..-1].empty?
      puts "You can't have empty arguments"
      exit
    end
    push(ARGV[1..-1])
    puts "Pushed"
    exit
  else
    puts usage
    exit
end
